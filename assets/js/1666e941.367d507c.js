(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{124:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return p}));var a=t(0),l=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var c=l.a.createContext({}),h=function(e){var n=l.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},b=function(e){var n=h(e.components);return l.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return l.a.createElement(l.a.Fragment,{},n)}},u=l.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=h(t),u=a,p=b["".concat(i,".").concat(u)]||b[u]||d[u]||r;return t?l.a.createElement(p,o(o({ref:n},c),{},{components:t})):l.a.createElement(p,o({ref:n},c))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=u;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var c=2;c<r;c++)i[c]=t[c];return l.a.createElement.apply(null,i)}return l.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},72:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return o})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return h}));var a=t(3),l=t(7),r=(t(0),t(124)),i={title:"StreamChat Cheat Sheet"},o={unversionedId:"cheat-sheet",id:"cheat-sheet",isDocsHomePage:!1,title:"StreamChat Cheat Sheet",description:"This cheat sheet provides additional information to the official StreamChat SDK documentation on our website. You can find here more detailed information, richer code snippets, and commentary to the provided solutions.",source:"@site/docs/cheat-sheet.md",slug:"/cheat-sheet",permalink:"/stream-chat-swift/cheat-sheet",editUrl:"https://github.com/GetStream/stream-chat-swift/edit/main/stream-chat-swift-docs/docs/cheat-sheet.md",version:"current"},s=[{value:"Chat Client",id:"chat-client",children:[{value:"Creating a New Instance of Chat Client",id:"creating-a-new-instance-of-chat-client",children:[]},{value:"How Many <code>ChatClient</code> Instances Do I Need?",id:"how-many-chatclient-instances-do-i-need",children:[]}]},{value:"User",id:"user",children:[{value:"Setting the current user",id:"setting-the-current-user",children:[]},{value:"Logging out",id:"logging-out",children:[]}]},{value:"Connection",id:"connection",children:[{value:"Handling the connection manually",id:"handling-the-connection-manually",children:[]},{value:"Observing connection changes",id:"observing-connection-changes",children:[]}]},{value:"Channel List",id:"channel-list",children:[{value:"Getting the Channels with the Current User as Member",id:"getting-the-channels-with-the-current-user-as-member",children:[]}]},{value:"Channel",id:"channel",children:[{value:"Getting Messages in the Channel",id:"getting-messages-in-the-channel",children:[]},{value:"Creating a new Channel",id:"creating-a-new-channel",children:[]},{value:"Creating a new 1-1 Channel",id:"creating-a-new-1-1-channel",children:[]}]},{value:"Messages",id:"messages",children:[{value:"Sending a Message",id:"sending-a-message",children:[]},{value:"Deleting a Message",id:"deleting-a-message",children:[]},{value:"Editing a Message",id:"editing-a-message",children:[]}]},{value:"Working with Extra Data",id:"working-with-extra-data",children:[{value:"What is Extra Data",id:"what-is-extra-data",children:[]},{value:"Defining Custom Extra Data",id:"defining-custom-extra-data",children:[]}]},{value:"Under the Hood",id:"under-the-hood",children:[]}],c={toc:s};function h(e){var n=e.components,t=Object(l.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This cheat sheet provides additional information to the official ",Object(r.b)("a",{parentName:"p",href:"https://getstream.io/chat/docs/introduction/?language=swift"},"StreamChat SDK documentation")," on our website. You can find here more detailed information, richer code snippets, and commentary to the provided solutions."),Object(r.b)("h4",{id:"summary"},"Summary"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#chat-client"},"Chat Client"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#creating-a-new-instance-of-chat-client"},"Creating a New Instance of Chat Client")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#how-many-chatclient-instances-do-i-need"},"How Many ChatClient Instances Do I Need?")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#user"},"User"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#setting-the-current-user"},"Setting the current user")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#logging-out"},"Logging out")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#connection"},"Connection"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#handling-the-connection-manually"},"Handling the connection manually")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#observing-connection-changes"},"Observing connection changes")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#channel-list"},"Channel List"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#getting-the-channels-with-the-current-user-as-member"},"Getting the Channels with the Current User as Member")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#channel"},"Channel"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#getting-messages-in-the-channel"},"Getting Messages in the Channel")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#creating-a-new-channel"},"Creating a new Channel")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#creating-a-new-1-1-channel"},"Creating a new 1-1 Channel")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#messages"},"Messages"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#sending-a-message"},"Sending a Message")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#deleting-a-message"},"Deleting a Message")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#editing-a-message"},"Editing a Message")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#working-with-extra-data"},"Working with Extra Data"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#what-is-extra-data"},"What is Extra Data")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#defining-custom-extra-data"},"Defining Custom Extra Data")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",{parentName:"li",href:"#under-the-hood"},"Under the Hood"))),Object(r.b)("hr",null),Object(r.b)("p",null,"Didn't find what you were looking for? Open an ",Object(r.b)("a",{parentName:"p",href:"https://github.com/GetStream/stream-chat-swift/issues"},"issue in our repo")," and suggest a new topic!"),Object(r.b)("hr",null),Object(r.b)("h2",{id:"chat-client"},"Chat Client"),Object(r.b)("h3",{id:"creating-a-new-instance-of-chat-client"},"Creating a New Instance of Chat Client"),Object(r.b)("p",null,"There are several basic approaches to creating a ",Object(r.b)("inlineCode",{parentName:"p"},"ChatClient")," instance."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"In the most simple setup, you can create a singleton instance")," of ",Object(r.b)("inlineCode",{parentName:"p"},"ChatClient")," and access it from everywhere:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},'extension ChatClient {\n    /// The singleton instance of `ChatClient`\n    static let shared: ChatClient = {\n        let config = ChatClientConfig(apiKey: APIKey("qk4nn7rpcn75"))\n        return ChatClient(config: config, tokenProvider: .closure { chatClient, completion in\n            let token = ... // Provide the StreamChat token for the current user\n            completion(.success(token))\n        })\n    }()\n}\n')),Object(r.b)("p",null,"Another approach is to ",Object(r.b)("strong",{parentName:"p"},"create ",Object(r.b)("inlineCode",{parentName:"strong"},"ChatClient")," instance only locally and pass it down to the view controller hierarchy"),". "),Object(r.b)("p",null,"For example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},'class AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) Bool {\n        let config = ChatClientConfig(apiKey: APIKey("qk4nn7rpcn75"))\n        let chatClient = ChatClient(config: config, tokenProvider: .closure { chatClient, completion in\n            let token = ... // Provide the StreamChat token for the current user\n            completion(.success(token))\n        })\n        \n        let rootViewController = YourMainViewController(chatClient: chatClient)\n        \n        // your code to make rootViewController visible\n\n        return true\n    }\n}\n')),Object(r.b)("h3",{id:"how-many-chatclient-instances-do-i-need"},"How Many ",Object(r.b)("inlineCode",{parentName:"h3"},"ChatClient")," Instances Do I Need?"),Object(r.b)("p",null,"For the absolute majority of use cases, an app needs one instance of the ",Object(r.b)("inlineCode",{parentName:"p"},"Client")," object. "),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"You need multiple ",Object(r.b)("inlineCode",{parentName:"strong"},"Client")," instances in one app when:")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"You want to simultaneously show content from multiple different chats (with different ",Object(r.b)("inlineCode",{parentName:"li"},"AppId")," values)"),Object(r.b)("li",{parentName:"ul"},"You want to simultaneously show the same content as seen for different kinds of users. For example, the left window for an admin user, the right window for an anonymous user. In this case, it's recommended to always use ",Object(r.b)("inlineCode",{parentName:"li"},"isLocalStorageEnabled = false")," configuration.")),Object(r.b)("h2",{id:"user"},"User"),Object(r.b)("h3",{id:"setting-the-current-user"},"Setting the current user"),Object(r.b)("p",null,"A valid StreamChat ",Object(r.b)("inlineCode",{parentName:"p"},"token")," is all you need to properly set your current app user as the current user of ",Object(r.b)("inlineCode",{parentName:"p"},"ChatClient"),". This token can't be created locally and it must be provided by your backend."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"ChatClient")," uses ",Object(r.b)("inlineCode",{parentName:"p"},"TokenProvider")," to fetch the token of the currently logged in user from you. There are several types of ",Object(r.b)("inlineCode",{parentName:"p"},"TokenProvider"),"s you can choose from:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},'/// A token provider accepting a closure as a parameter. This is most likely the provider you \n/// want to use in your production app.\nchatClient.tokenProvider = .closure { chatClient, completion in \n  let token = ... // Obtain the chat token from your system\n  completion(token)\n}\n\n/// A token provider for anonymous users. You\'d use this provider for situations when no\n/// specific user is logged in.\nchatClient.tokenProvider = .anonymous\n\n/// A token provider for a guest user with the specific <id> and name.\nchatClient.tokenProvider = .guest(userId: <id>, name: "Luke", imageURL: nil)\n\n/// A token provider returning the hardcoded token\nchatClient.tokenProvider = .static(<token>)\n\n/// A token provider that can be used for development. Development tokens are not validated by the servers.\nchatClient.tokenProvider = .development(userId: <id>)\n')),Object(r.b)("p",null,"When the currently logged-in user of the app changes, or when you assign a new token provider to ",Object(r.b)("inlineCode",{parentName:"p"},"ChatClient"),", you should tell ",Object(r.b)("inlineCode",{parentName:"p"},"ChatClient")," to reload its current user:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"/// Gets a new token from `TokenProvider` and if the new user id differs from the current one, \n/// reloads the data and reconnects with the new user.\nchatClient.currentUserController().reloadUserIfNeeded()\n")),Object(r.b)("h3",{id:"logging-out"},"Logging out"),Object(r.b)("p",null,"It's impossible to log out a user because the ",Object(r.b)("inlineCode",{parentName:"p"},"Client")," instance must always have a user assigned. "),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"However, you can simulate this behavior by:")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Destroying the current ",Object(r.b)("inlineCode",{parentName:"strong"},"Client")," instance"))),Object(r.b)("p",null,"You can destroy all references to the ",Object(r.b)("inlineCode",{parentName:"p"},"Client")," instance once you don't need it. Every ",Object(r.b)("inlineCode",{parentName:"p"},"Controller")," holds a strong reference to the parent ",Object(r.b)("inlineCode",{parentName:"p"},"Client")," instance. You can use this to your advantage and have your view controllers holding a strong reference to ",Object(r.b)("inlineCode",{parentName:"p"},"Client")," via their referenced controllers. Once all view controllers are deallocated, so are the controllers and, finally, the ",Object(r.b)("inlineCode",{parentName:"p"},"Client")," instance."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"or ",Object(r.b)("strong",{parentName:"li"},"Setting the current user as anonymous"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"chatClient.tokenProvider = .anonymous\nchatClient.currentUserController().reloadUserIfNeeded()\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"or ",Object(r.b)("strong",{parentName:"li"},"Disconnecting the client"))),Object(r.b)("p",null,"This method makes the ",Object(r.b)("inlineCode",{parentName:"p"},"Client")," instance stop receiving any updates from the server. You can later reconnect without having to set the current user again."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"chatClient.connectionController().disconnect()\n\n// when you want to reconnect\n\nchatClient.connectionController().connect { error in \n    if error == nil {\n       // connection successful\n    }\n}\n")),Object(r.b)("h2",{id:"connection"},"Connection"),Object(r.b)("h3",{id:"handling-the-connection-manually"},"Handling the connection manually"),Object(r.b)("p",null,"If ",Object(r.b)("inlineCode",{parentName:"p"},"config.shouldConnectAutomatically")," is set to ",Object(r.b)("inlineCode",{parentName:"p"},"false")," the establishment of a web-socket connection has to be done manually via ",Object(r.b)("inlineCode",{parentName:"p"},"connect/disconnect")," in ",Object(r.b)("inlineCode",{parentName:"p"},"ChatConnectionController"),", otherwise this is done automatically in the ",Object(r.b)("inlineCode",{parentName:"p"},"CurrentUserController")," when setting the current user."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"chatClient.connectionController().connect { error in \n    if error == nil {\n       // connection successful\n    }\n}\n// disconnecting\nchatClient.connectionController().disconnect()\n")),Object(r.b)("h3",{id:"observing-connection-changes"},"Observing connection changes"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using UIKit and Delegates"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class LoggedInUserViewController: UIViewController {\n    ...\n    override func viewDidLoad() {\n       super.viewDidLoad()\n       chatClient.connectionController.delegate = self\n    }\n}\n\nextension LoggedInUserViewController: ChatConnectionControllerDelegate {\n    func connectionController(_ controller: ChatConnectionController, didUpdateConnectionStatus status: ConnectionStatus) {\n        switch status {\n        case .connected:\n            onlineIndicatorView.tintColor = .green\n        case .disconnected, .disconnecting,  .initialized:\n            onlineIndicatorView.tintColor = .red\n        case .connecting:\n            break\n        }\n    }\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using UIKit and Combine"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class LoggedInUserViewController: UIViewController {\n    \nprivate var cancellables: Set<AnyCancellable> = []\n\n    override func viewDidLoad() {\n       super.viewDidLoad()\n\n        chatClient\n             .connectionController\n             .channelsChangesPublisher\n             .receive(on: RunLoop.main)\n             .sink { [weak self] state in\n                // state changed\n             }\n             .store(in: &cancellables)\n    }\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using SwiftUI and Combine"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},'struct LoggedInUserView: View {\n    @ObservedObject var connection: ChatConnectionController.ObservableObject\n\n    init(connectionController: ChatConnectionController) {\n        self.connection = connectionController.observableObject\n    }\n\n    var body: some View {\n        switch connection.connectionStatus {\n         case .connected:\n             Text("Connected")\n         case .disconnected, .disconnecting:\n             Text("Disconnected")\n         case .connecting, .initialized:\n             Text("Connecting")\n         }\n        .navigationBarTitle("Logged In User")\n    }\n}\n')),Object(r.b)("h2",{id:"channel-list"},"Channel List"),Object(r.b)("h3",{id:"getting-the-channels-with-the-current-user-as-member"},"Getting the Channels with the Current User as Member"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using UIKit and Delegates"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class ChannelListViewController: UIViewController {\n\n    let channelListController = chatClient.channelListController(\n       query: ChannelListQuery(filter: .containMembers(userIds: [chatClient.currentUserId]))\n    )\n\n    override func viewDidLoad() {\n       super.viewDidLoad()\n       channelListController.delegate = self\n\n       // update your UI with the cached channels first, for example by calling reloadData() on UITableView\n       let locallyAvailableChannels = channelListController.channels\n\n       // call `synchronize()` to update the locally cached data. the updates will be delivered using delegate methods\n       channelListController.synchronize()\n    }\n}\n\nextension ChannelListViewController: ChatChannelListControllerDelegate { \n    func controller(_ controller: ChatChannelListController, didChangeChannels changes: [ListChange<Channel>]) {\n        // The list of channels has changed. You can for example animate the changes:\n\n        tableView.beginUpdates()        \n        for change in changes {\n            switch change {\n            case let .insert(_, index: index):\n                tableView.insertRows(at: [index], with: .automatic)\n            // etc ...\n            }\n        }        \n        tableView.endUpdates()\n    }\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using UIKit and Combine"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class ChannelsViewController: UIViewController {\n\n    let channelListController = chatClient.channelListController(\n       query: ChannelListQuery(filter: .containMembers(userIds: [chatClient.currentUserId]))\n    )\n\n    private var cancellables: Set<AnyCancellable> = []\n\n    override func viewDidLoad() {\n       super.viewDidLoad()\n\n       // update your UI with the cached channels first, for example by calling reloadData() on UITableView\n       let locallyAvailableChannels = channelListController.channels\n\n       // Observe changes to the list from the publishers\n        channelListController\n             .channelsChangesPublisher\n             .receive(on: RunLoop.main)\n             .sink { [weak self] changes in\n                // animate the changes to the channel list\n             }\n             .store(in: &cancellables)\n\n       // call `synchronize()` to update the locally cached data. the updates will be delivered using channelsChangesPublisher\n       channelListController.synchronize()\n    }\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using SwiftUI"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},'\n// View definition\n\nstruct ChannelListView: View {\n    @ObservedObject var channelList: ChatChannelListController.ObservableObject\n\n    init(channelListController: ChatChannelListController) {\n        self.channelList = channelListController.observableObject\n    }\n\n    var body: some View {\n        VStack {\n            List(channelList.channels, id: \\.self) { channel in\n                Text(channel.extraData.name ?? "missing channel name")\n            }\n        }\n        .navigationBarTitle("Channels")\n        .onAppear { \n            // call `synchronize()` to update the locally cached data.\n            channelList.synchronize() \n        }\n    }\n}\n\n// Usage\n\nlet channelListController = chatClient.channelListController(\n    query: ChannelListQuery(filter: .containMembers(userIds: [chatClient.currentUserId]))\n)\n\nlet view = ChannelListView(channelListController: channelListController)\n')),Object(r.b)("h2",{id:"channel"},"Channel"),Object(r.b)("h3",{id:"getting-messages-in-the-channel"},"Getting Messages in the Channel"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using UIKit and Delegates"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class ChannelViewController: UIViewController {\n\n   let channelController = chatClient.channelController(cid: <id of the channel>)\n\n   override func viewDidLoad() {\n       super.viewDidLoad()\n       channelController.delegate = self\n\n       // update your UI with the cached messages first, for example by calling reloadData() on UITableView\n       let locallyAvailableMessages = channelController.messages\n\n       // call `synchronize()` to update the locally cached data. the updates will be delivered using delegate methods\n       channelController.synchronize()\n   }\n}\n\nextension ChannelViewController: ChatChannelControllerDelegate { \n    func channelController(_ channelController: ChatChannelController, didUpdateMessages changes: [ListChange<ChatMessage>]) {\n        // For example, you can animate the changes in UITableView\n        tableView.beginUpdates()\n        \n        for change in changes {\n            switch change {\n            case let .insert(_, index: index):\n                tableView.insertRows(at: [index], with: .automatic)\n            case let .move(_, fromIndex: fromIndex, toIndex: toIndex):\n                tableView.moveRow(at: fromIndex, to: toIndex)\n            case let .update(_, index: index):\n                tableView.reloadRows(at: [index], with: .automatic)\n            case let .remove(_, index: index):\n                tableView.deleteRows(at: [index], with: .automatic)\n            }\n        }\n        \n        tableView.endUpdates()\n    }\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using UIKit and Combine"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class ChannelViewController: UIViewController {\n\n   let channelController = chatClient.channelController(cid: <id of the channel>)\n\n   private var cancellables: Set<AnyCancellable> = []\n\n   override func viewDidLoad() {\n       super.viewDidLoad()\n\n       // update your UI with the cached messages first, for example by calling reloadData() on UITableView\n       let locallyAvailableMessages = channelController.messages\n\n       // Observe changes to the list of messages\n        channelListController\n             .messagesChangesPublisher\n             .receive(on: RunLoop.main)\n             .sink { [weak self] changes in\n                // animate the changes to the message list\n             }\n             .store(in: &cancellables)\n   }\n}\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Using SwiftUI"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},'\n// View definition\nstruct ChannelView: View {\n    @ObservedObject var channelController: ChatChannelController.ObservableObject\n\n    init(channelController: ChatChannelController) {\n        self.channelController = channelController.observableObject\n    }\n\n    var body: some View {\n        VStack {\n            List(channelController.messages, id: \\.self) { message in\n                Text(message.text)\n            }\n        }\n        .navigationBarTitle(channelController.channel.name ?? "Messages")\n        .onAppear { \n            // call `synchronize()` to start updating the cached data\n            channelController.synchronize() \n        }\n    }\n}\n\n// Usage\nlet channelController = chatClient.channelController(cid: <channel id>)\nlet view = ChannelView(channelController: channelController)\n\n')),Object(r.b)("h3",{id:"creating-a-new-channel"},"Creating a new Channel"),Object(r.b)("p",null,"You can create a new channel by creating a ",Object(r.b)("inlineCode",{parentName:"p"},"ChannelController")," for it and calling ",Object(r.b)("inlineCode",{parentName:"p"},"synchronize { error in ... }"),". Once the completion block of ",Object(r.b)("inlineCode",{parentName:"p"},"synchronize")," is called, and the provided ",Object(r.b)("inlineCode",{parentName:"p"},"error")," is ",Object(r.b)("inlineCode",{parentName:"p"},"nil"),", the channel creation was successful."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"// A unique identifier of a channel\nlet id = UUID().uuidString\n\n// A `ChannelId` for the new channel. `ChannelId` is a combination of channel's type and a unique identifier of the channel.\nlet cid = ChannelId(type: .messaging, id: id)\n\nlet controller = chatClient.channelController(\n    createChannelWithId: cid, // Assign `cid` for the new channel\n    members: [chatClient.currentUserId], // Add users to the new channel\n    extraData: .init(name: \"My new channel\", imageURL: nil) // Set the name for the channel\n)\n\n// At this point, the channel does not exist yet, but you can use the `controller` already. \n//\n// This is handy for optimistic UI updates. You can already show the chat UI to the user while\n// the channel is being created. The message sending UI should be disabled until the `controller`'s state \n// changes to `remoteDataFetched`.\nlet someViewController = SomeViewController(channelController: controller)\n\n// ... your code to present the view controller\n\n// The channel is created when `synchronize { }` is called:\ncontroller.synchronize { error in\n    if error == nil {\n        // The channel was successfully created\n    }\n} \n")),Object(r.b)("h3",{id:"creating-a-new-1-1-channel"},"Creating a new 1-1 Channel"),Object(r.b)("p",null,"Direct messaging channels derived their ",Object(r.b)("inlineCode",{parentName:"p"},"ChannelId")," automatically from their members. You can create a new 1-1 channel by creating a ",Object(r.b)("inlineCode",{parentName:"p"},"ChannelController")," for it and calling ",Object(r.b)("inlineCode",{parentName:"p"},"synchronize { error in ... }"),". Once the completion block of ",Object(r.b)("inlineCode",{parentName:"p"},"synchronize")," is called, and the provided ",Object(r.b)("inlineCode",{parentName:"p"},"error")," is ",Object(r.b)("inlineCode",{parentName:"p"},"nil"),", the channel creation was successful."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"\nlet newChannelMemberIds: Set<UserId> = [chatClient.currentUserId, someOtherUserId]\n\nlet controller = chatClient.channelController(createDirectMessageChannelWith: newChannelMemberIds)\n\n// At this point, the channel does not exist created yet, but you can use the `controller` already. \n//\n// This is handy for optimistic UI updates. You can already show the chat UI to the user while\n// the channel is being created. The message sending UI should be disabled until the `controller`'s state \n// changes to `remoteDataFetched`. \n// \n// If there are some existing messages between the current user and `someOtherUser`, they will\n// be loaded automatically by `controller`.\nlet someViewController = SomeViewController(channelController: controller)\n\n// ... your code to present the view controller\n\n// The channel is created when `synchronize { }` is called:\ncontroller.synchronize { error in\n    if error == nil {\n        // The channel was successfully created\n    }\n} \n")),Object(r.b)("h2",{id:"messages"},"Messages"),Object(r.b)("h3",{id:"sending-a-message"},"Sending a Message"),Object(r.b)("p",null,"Sending a new message to a channel has several phases."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"Message.localState")," phases when sending a message:")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"                                    \u250c\u2500\u2500\u25b6  `nil` if success \n  `pendingSend` \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 `sending` \u2500\u2500\u2524                      \n                                    \u2514\u2500\u25b6   `sendingFailed`                                                         \n")),Object(r.b)("p",null,"This behavior makes it possible to update your UI with the new message immediately without blocking the UI."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class MyChannelViewController: UIViewController {\n    let controller = ChannelController(cid: <id of the channel>)\n\n    func sendMessage(text: String) {\n        // This method creates a new message locally, initially with `localState == .pendingSend`\n        controller.createNewMessage(text: text)\n    }\n\n    // Example handling for Message local state:\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) UITableViewCell { \n        ...\n        let message = controller.messages[indexPath.row]\n        if message.localState == .pendingSend {\n            // show message as pending send\n\n        } else if message.localState == .sendingFailed {\n            // show retry button for the message\n        }\n        ...\n    }\n}\n")),Object(r.b)("h3",{id:"deleting-a-message"},"Deleting a Message"),Object(r.b)("p",null,"Deleting a message is performed using a ",Object(r.b)("inlineCode",{parentName:"p"},"MessageController")," created for the given message."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"Message.localState")," phases when deleting a message:")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"                \u250c\u2500\u2500\u25b6  `nil` if success \n   `deleting` \u2500\u2500\u2524                      \n                \u2514\u2500\u25b6  `deletingFailed`                                \n")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class MyChannelViewController: UIViewController {\n    let controller = ChannelController(cid: <id of the channel>)\n\n    func deleteMessage(message: Message) {\n        // Create a `MessageController` for the message you want to delete\n        let messageController = controller.client.messageController(\n            cid: channelController.channelQuery.cid,\n            messageId: message.id\n        )\n\n        // Delete the message\n        messageController.deleteMessage()\n    }\n\n    // Example handling for Message local state:\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) UITableViewCell { \n        ...\n        let message = controller.messages[indexPath.row]\n        if message.localState == .deleting {\n            // show message as being deleted\n\n        } else if message.localState == .deletingFailed {\n            // show retry button for deleting the message\n        }\n        ...\n    }\n}\n")),Object(r.b)("h3",{id:"editing-a-message"},"Editing a Message"),Object(r.b)("p",null,"Editing a message has several phases."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},Object(r.b)("inlineCode",{parentName:"strong"},"MessageModel.localState")," phases when editing a message:")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"                                    \u250c\u2500\u2500\u25b6  `nil` if success \n  `pendingSync` \u2500\u2500\u2500\u2500\u2500\u2500\u25b6 `syncing` \u2500\u2500\u2524                      \n                                    \u2514\u2500\u25b6   `syncingFailed`                                                         \n")),Object(r.b)("p",null,"This behavior makes it possible to update your UI with the updated message immediately without blocking the UI."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"class MyChannelViewController: UIViewController {\n    let controller = ChannelController(cid: <id of the channel>)\n\n    func editMessage(message: ChatMessage, text: String) {\n        let messageController = controller.client.messageController(cid: <id of the channel>, messageId: message.id)\n\n        // This method updates a message locally with the `localState == .pendingSync`\n        messageController.editMessage(text: text)\n    }\n\n    // Example handling for Message local state:\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) UITableViewCell { \n        ...\n        let message = controller.messages[indexPath.row]\n        if message.localState == .pendingSync {\n            // show message as not being synced with the servers\n\n        } else if message.localState == .syncingFailed {\n            // show retry button\n        }\n        ...\n    }\n}\n")),Object(r.b)("h2",{id:"working-with-extra-data"},"Working with Extra Data"),Object(r.b)("h3",{id:"what-is-extra-data"},"What is Extra Data"),Object(r.b)("p",null,"You can add additional (extra) data to entities in the chat system. For now, you can add extra data to ",Object(r.b)("inlineCode",{parentName:"p"},"ChatUser"),", ",Object(r.b)("inlineCode",{parentName:"p"},"ChatChannel"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"ChatMessage"),"."),Object(r.b)("p",null,"The extra data types are defined using the ",Object(r.b)("inlineCode",{parentName:"p"},"ExtraDataTypes")," protocol the ",Object(r.b)("inlineCode",{parentName:"p"},"ChatClient")," and other types are generic over. Here you can see the protocol declaration including the default extra data types for the mentioned entities:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"public protocol ExtraDataTypes {\n    /// An extra data type for `ChatUser`.\n    associatedtype User: UserExtraData = NoExtraData\n    \n    /// An extra data type for `ChatMessage`.\n    associatedtype Message: MessageExtraData = NoExtraData\n    \n    /// An extra data type for `ChatChannel`.\n    associatedtype Channel: ChannelExtraData = NoExtraData\n    \n    /// An extra data type for `ChatMessageReaction`.\n    associatedtype MessageReaction: MessageReactionExtraData = NoExtraData\n    \n    /// An extra data type for `ChatMessageAttachment`.\n    associatedtype Attachment: AttachmentExtraData = NoExtraData\n}\n\nclass _ChatClient<ExtraData: ExtraDataTypes> { ... }\n\n")),Object(r.b)("p",null,"To make working with generic types more convenient, we expose several typealiases. This way, generic types' underlying extra data complexity is hidden, while the whole system stays safe at compile-time. "),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"/// A convenience typealias for `ChatClient` with the default data types.\npublic typealias ChatClient = _ChatClient<NoExtraData>\n\n/// A convenience typealias for `ChatUser` with the default data types.\npublic typealias ChatUser = _ChatUser<NoExtraData>\n\n/// A convenience typealias for `ChatChannel` with the default data types.\npublic typealias ChatChannel = _Chatchannel<NoExtraData>\n\n...\n\n")),Object(r.b)("hr",null),Object(r.b)("p",null,"\u26a0\ufe0f ",Object(r.b)("strong",{parentName:"p"},"Important:")," If the name of the type has the ",Object(r.b)("inlineCode",{parentName:"p"},"_")," prefix, it's not meant to be used directly. You should instead use the convenience typealias without the prefix."),Object(r.b)("hr",null),Object(r.b)("h3",{id:"defining-custom-extra-data"},"Defining Custom Extra Data"),Object(r.b)("p",null,"Changing the default extra data types with your custom types is easy and takes a couple of easy steps."),Object(r.b)("p",null,"For example, let's say you want to replace the default ",Object(r.b)("inlineCode",{parentName:"p"},"NoExtraData")," of ",Object(r.b)("inlineCode",{parentName:"p"},"ChatChannel")," with your custom ",Object(r.b)("inlineCode",{parentName:"p"},"NameAndColorExtraData"),":"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"1. Define your custom Channel extra data type")),Object(r.b)("p",null,"Your custom data type must conform to the ",Object(r.b)("inlineCode",{parentName:"p"},"ChannelExtraData")," protocol. The protocol has two requirements: the type must be codable, and it must expose a static ",Object(r.b)("inlineCode",{parentName:"p"},"defaultValue")," variable."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},'/// Your custom ChatChannel extra data type\nstruct NameAndColorExtraData: ChannelExtraData {\n    \n    /// The value used when decoding the custom data type fails.\n    static var defaultValue = NameAndColorExtraData(name: "Unknown", colorName: nil)\n    \n    let name: String\n    let colorName: String?\n}\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"2. Use the type in your custom implementation of ",Object(r.b)("inlineCode",{parentName:"strong"},"ExtraDataTypes"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"/// Custom implementation of `ExtraDataTypes` with `NameAndColorExtraData`\nenum MyCustomExtraData: ExtraDataTypes {\n    typealias Channel = NameAndColorExtraData\n\n    // Note: Unless you specify other custom data types, the default data types are used.\n}\n")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"3. Define the following typealiases in your module")),Object(r.b)("p",null,"You should define the convenience typealiases in the module where you use ",Object(r.b)("inlineCode",{parentName:"p"},"StreamChat"),". You can copy&paste the snippet below, and replace ",Object(r.b)("inlineCode",{parentName:"p"},"MyCustomExtraData")," with the type defined in step 2."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-swift"},"import StreamChat\n\n// Change this typealias to your custom data types\ntypealias CustomExtraDataTypes = MyCustomExtraData // \ud83d\udc48 Your_Custom_Data_Type_Here \ud83d\udc48\n\ntypealias ChatClient = _ChatClient<CustomExtraDataTypes>\n\ntypealias ChatUser = _ChatUser<CustomExtraDataTypes.User>\ntypealias CurrentChatUser = _CurrentChatUser<CustomExtraDataTypes.User>\ntypealias ChatChannel = _ChatChannel<CustomExtraDataTypes> \ntypealias ChatChannelRead = _ChatChannelRead<CustomExtraDataTypes>\ntypealias ChatChannelMember = _ChatChannelMember<CustomExtraDataTypes.User>\ntypealias ChatMessage = _ChatMessage<CustomExtraDataTypes> \n\ntypealias CurrentChatUserController = _CurrentChatUserController<CustomExtraDataTypes>\ntypealias ChatChannelListController = _ChatChannelListController<CustomExtraDataTypes>\ntypealias ChatChannelController = _ChatChannelController<CustomExtraDataTypes>\ntypealias ChatMessageController = _ChatMessageController<CustomExtraDataTypes>\n\n")),Object(r.b)("h4",{id:"important"},Object(r.b)("strong",{parentName:"h4"},"Important")),Object(r.b)("p",null,"Extra data is embedded directly to the root object, not nested under any ",Object(r.b)("inlineCode",{parentName:"p"},"extraData")," object."),Object(r.b)("p",null,"So if you have such a Channel object:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"{\n  'id': ....,\n  // all other default fields\n  'color': 'red'\n}\n")),Object(r.b)("p",null,"You'd use the ",Object(r.b)("inlineCode",{parentName:"p"},"MyCustomExtraData")," defined above."),Object(r.b)("h2",{id:"under-the-hood"},"Under the Hood"),Object(r.b)("p",null,"This section contains additional information about the SDK, which might help you use it best. However, you don't need to know such details for most use cases to use it in your project successfully."),Object(r.b)("p",null,"WIP"))}h.isMDXComponent=!0}}]);